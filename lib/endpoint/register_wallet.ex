defmodule ExLemonway.Endpoint.RegisterWallet do
  @moduledoc """
  Endpoint for RegisterWallet.

  It's automatically generated by `mix specs.gen.endpoint RegisterWallet`
  Dont' edit this file manually, to make any changes, please update:
  `specs/directkit/endpoint/register_wallet/request.json`
  or `specs/directkit/endpoint/register_wallet/response.json`
  """

  defmodule Request do
    defstruct birthcity: nil,
              birthcountry: nil,
              birthdate: nil,
              city: nil,
              client_first_name: nil,
              client_last_name: nil,
              client_mail: nil,
              client_title: nil,
              company_description: nil,
              company_identification_number: nil,
              company_name: nil,
              company_website: nil,
              ctry: nil,
              is_company: nil,
              is_debtor: nil,
              is_one_time_customer: nil,
              is_tech_wallet: nil,
              mobile_number: nil,
              nationality: nil,
              payer_or_beneficiary: nil,
              phone_number: nil,
              post_code: nil,
              street: nil,
              wallet: nil

    @doc """
    Convert structured request into payload map according to specs.
    """
    @spec to_payload(Request.t()) :: map()
    def to_payload(%Request{} = data) do
      Enum.reduce(Map.from_struct(data), %{}, fn
        {key, %{__struct__: model_module} = value}, payload ->
          field = key_to_field(key)
          inner_payload = Module.concat(model_module, Parser).to_payload(value)
          Map.put(payload, field, inner_payload)

        {key, value}, payload ->
          Map.put(payload, key_to_field(key), value)
      end)
    end

    @doc """
    Convert raw string key into struct key atom.
    """
    @spec field_to_key(String.t()) :: atom()
    def field_to_key("birthcity"), do: :birthcity
    def field_to_key("birthcountry"), do: :birthcountry
    def field_to_key("birthdate"), do: :birthdate
    def field_to_key("city"), do: :city
    def field_to_key("clientFirstName"), do: :client_first_name
    def field_to_key("clientLastName"), do: :client_last_name
    def field_to_key("clientMail"), do: :client_mail
    def field_to_key("clientTitle"), do: :client_title
    def field_to_key("companyDescription"), do: :company_description
    def field_to_key("companyIdentificationNumber"), do: :company_identification_number
    def field_to_key("companyName"), do: :company_name
    def field_to_key("companyWebsite"), do: :company_website
    def field_to_key("ctry"), do: :ctry
    def field_to_key("isCompany"), do: :is_company
    def field_to_key("isDebtor"), do: :is_debtor
    def field_to_key("isOneTimeCustomer"), do: :is_one_time_customer
    def field_to_key("isTechWallet"), do: :is_tech_wallet
    def field_to_key("mobileNumber"), do: :mobile_number
    def field_to_key("nationality"), do: :nationality
    def field_to_key("payerOrBeneficiary"), do: :payer_or_beneficiary
    def field_to_key("phoneNumber"), do: :phone_number
    def field_to_key("postCode"), do: :post_code
    def field_to_key("street"), do: :street
    def field_to_key("wallet"), do: :wallet
    def field_to_key(_), do: nil

    @doc """
    Convert atomic key to original string key.
    """
    @spec key_to_field(atom()) :: String.t()
    def key_to_field(:birthcity), do: "birthcity"
    def key_to_field(:birthcountry), do: "birthcountry"
    def key_to_field(:birthdate), do: "birthdate"
    def key_to_field(:city), do: "city"
    def key_to_field(:client_first_name), do: "clientFirstName"
    def key_to_field(:client_last_name), do: "clientLastName"
    def key_to_field(:client_mail), do: "clientMail"
    def key_to_field(:client_title), do: "clientTitle"
    def key_to_field(:company_description), do: "companyDescription"
    def key_to_field(:company_identification_number), do: "companyIdentificationNumber"
    def key_to_field(:company_name), do: "companyName"
    def key_to_field(:company_website), do: "companyWebsite"
    def key_to_field(:ctry), do: "ctry"
    def key_to_field(:is_company), do: "isCompany"
    def key_to_field(:is_debtor), do: "isDebtor"
    def key_to_field(:is_one_time_customer), do: "isOneTimeCustomer"
    def key_to_field(:is_tech_wallet), do: "isTechWallet"
    def key_to_field(:mobile_number), do: "mobileNumber"
    def key_to_field(:nationality), do: "nationality"
    def key_to_field(:payer_or_beneficiary), do: "payerOrBeneficiary"
    def key_to_field(:phone_number), do: "phoneNumber"
    def key_to_field(:post_code), do: "postCode"
    def key_to_field(:street), do: "street"
    def key_to_field(:wallet), do: "wallet"
  end

  defmodule Response do
    require Logger

    defstruct wallet: nil

    @lemonway_atomic_types Mix.ExLemonway.ModelSpecs.lemonway_atomic_types()
                           |> Enum.map(&String.to_atom/1)

    # Some autogenerated responses may not have lemonway_atomic_types,
    # so that much is redundant and triggers warning, which does no harm.
    @dialyzer {:no_match, from_data: 1}

    @doc """
    Convert raw string key into struct key atom.
    """
    @spec field_to_key(String.t()) :: atom()
    def field_to_key("WALLET"), do: :wallet
    def field_to_key(_), do: nil

    @doc """
    Convert atomic key to original string key.
    """
    @spec key_to_field(atom()) :: String.t()
    def key_to_field(:wallet), do: "WALLET"

    @doc """
    Get expected type by a field name.
    """
    @spec field_type(String.t()) :: atom()
    def field_type("WALLET"), do: Wallet
    def field_type(_), do: :unknown

    @doc """
    Convert raw response to a Response struct.
    """
    @spec from_data(map()) :: {:ok, __MODULE__.t()} | {:error, :parsing_failed}
    def from_data(data) do
      IO.inspect(data)

      Enum.reduce_while(data, {:ok, %__MODULE__{}}, fn {field, value}, {:ok, response} ->
        key = field_to_key(field)
        type = field_type(field)

        cond do
          is_list(value) ->
            parser = Module.concat([Elixir.ExLemonway, type, Parser])

            submodels =
              Enum.reduce_while(value, [], fn raw_value, acc ->
                case parser.to_struct(raw_value) do
                  {:ok, submodel} ->
                    {:cont, acc ++ [submodel]}

                  error ->
                    {:halt, error}
                end
              end)

            case submodels do
              submodels when is_list(submodels) ->
                {:cont, {:ok, Map.put(response, key, submodels)}}

              error ->
                {:halt, error}
            end

          type === :unknown ->
            Logger.warn("Uknown type for field '#{field}', skipped")
            {:cont, {:ok, response}}

          type in @lemonway_atomic_types ->
            {:cont, {:ok, Map.put(response, key, value)}}

          true ->
            parser = Module.concat([Elixir.ExLemonway, type, Parser])

            case parser.to_struct(value) do
              {:ok, submodel} ->
                {:cont, {:ok, Map.put(response, key, submodel)}}

              error ->
                {:halt, error}
            end
        end
      end)
    end
  end

  alias ExLemonway.Util
  alias ExLemonway.Behaviour.HttpClient

  @doc """
  Send API request to execute RegisterWallet.
  """
  @spec request(Request.t()) ::
          {:ok, Response.t()} | {:error, :parsing_failed | HttpClient.HttpError.t()}
  def request(%Request{} = data) do
    url = ExLemonway.config(:api_url) <> "/RegisterWallet"
    payload = Request.to_payload(data) |> ExLemonway.Util.Request.enhance_payload()

    with {:ok, %{"d" => response}} <- Util.Request.post(url, %{"p" => payload}) do
      case response do
        %{"E" => %{"Code" => code, "Msg" => message}} ->
          error = HttpClient.HttpError.new(message, String.to_integer(code))
          {:error, error}

        response ->
          Response.from_data(Map.drop(response, ["E", "__type"]))
      end
    end
  end
end
